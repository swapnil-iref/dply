#!/usr/bin/env ruby 
lib = File.expand_path(File.dirname(__FILE__) + '/../lib')
$LOAD_PATH.unshift(lib) if File.directory?(lib) && !$LOAD_PATH.include?(lib)

Signal.trap("INT") { exit 1 }

require 'optparse'
require 'dply/error'
require 'dply/version'
require 'dply/logger'
require 'dply/config'
require 'pathname'

logger = ::Dply::Logger.logger
options = {
  read_config: true
}

opts_parser = OptionParser.new do |opts| 
    
    banner = [] 
    banner << "Usage: drake [global options] command [options] args"
    banner << "Commands:"
    banner << "    deploy"
    banner << "    switch"
    banner << "    rollback"
    
    banner << "Options: "
    opts.banner = banner.join("\n")

    opts.on("-d", "--dir [DEPLOY DIR]" , "Set dir") do |d| 
      path = Pathname.new(d)
      raise ::Dply::Error, "deploy_dir path must be absolute" if path.relative?
      options[:deploy_dir] = path
    end

    opts.on("--no-config", "Do not read config file") do
      options[:read_config] = false
    end

    opts.on("-v", "--version", "Show version") do |v|
      puts ::Dply::VERSION
      exit
    end

    opts.on("--debug", "Show debug messages") do
      options[:debug] = true
      logger.level = ::Logger::DEBUG
    end

    opts.on("--trace", "Show debug messages and exception stack trace") do
      options[:debug] = true
      options[:trace] = true
      logger.level = ::Logger::DEBUG
    end

    opts.on_tail("-h", "--help", "Show this message") do 
      puts opts
      exit
    end 
end

begin
  opts_parser.order!(ARGV)
  deploy_dir = options[:deploy_dir] || Dir.pwd
  Dir.chdir deploy_dir
  config = Dply::Config.new(deploy_dir, read_config: options[:read_config]).to_struct

  command = (ARGV.shift || "").to_sym
  case command
  when :deploy
    require 'dply/cli/deploy'
    cli = Dply::Cli::Deploy.new(deploy_dir, config, ARGV)
    cli.run
  when :reload
    require 'dply/cli/reload'
    cli = Dply::Cli::Reload.new(deploy_dir, config, ARGV)
    cli.run
  when /[a-zA-Z_\-0-9]+[:][a-zA-Z_\-0-9]+/
    require 'dply/task_runner' 
  when :''
    puts opts_parser
  else
    raise Dply::Error, "no such command #{command}"
  end

rescue OptionParser::InvalidOption, OptionParser::MissingArgument, ::Dply::Error => e
  cause = e.cause
  if options[:trace]
    puts cause
    cause ? (raise cause) : (raise e)
  else
    logger.debug "#{cause.message}" if cause
    logger.error "#{e.message}"
    abort
  end
end

